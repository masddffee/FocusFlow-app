import { Task, EnhancedSubtask, SubtaskSegment } from "@/types/task";
import { TimeSlot, DayTimeSlots, ScheduledTask, CalendarEvent, DayOfWeek } from "@/types/timeSlot";
import { calculateDaysUntil } from "@/utils/timeUtils";
import { 
  getSubtaskRemainingTime, 
  getSubtaskTotalDuration,
  shouldSplitSubtask,
  calculateSubtaskSegments,
  getNextSessionDuration,
  initializeSubtaskProgress,
  getSubtaskOriginalDuration,
  validateAndProtectSubtaskDuration,
  getSubtaskDurationSafely
} from "./subtaskProgress";

// üÜï ÊéíÁ®ãÊ®°ÂºèÂÆöÁæ©
export type SchedulingMode = 'strict' | 'flexible';

export interface SchedulingModeOptions {
  mode: SchedulingMode;
  description: string;
  characteristics: string[];
}

export const SCHEDULING_MODES: Record<SchedulingMode, SchedulingModeOptions> = {
  strict: {
    mode: 'strict',
    description: 'Âö¥Ê†ºÊ®°Âºè - Áõ°Âø´ÂÆåÊàê',
    characteristics: [
      'ÊúÄÂ§ßÂåñÂà©Áî®ÊâÄÊúâÂèØÁî®ÊôÇÈñì',
      'ÂÑ™ÂÖàÂÆâÊéíÈï∑ÊôÇÊÆµÂ≠∏Áøí',
      'Á∑äÂØÜÊéíÁ®ãÔºåÊ∏õÂ∞ëÁ©∫Ê™î',
      'ÈÅ©ÂêàÁ∑äÊÄ•Êà™Ê≠¢Êó•Êúü'
    ]
  },
  flexible: {
    mode: 'flexible',
    description: 'ÂΩàÊÄßÊ®°Âºè - ËºïÈ¨ÜÂàÜÊï£',
    characteristics: [
      'ÂàÜÊï£ÊéíÁ®ãÔºåÈÅøÂÖçÈÅéÂ∫¶ÂØÜÈõÜ',
      '‰øùÁïôË∂≥Â§†‰ºëÊÅØÊôÇÈñì',
      'Êõ¥ÂùáÂãªÁöÑÂ∑•‰ΩúË≤†Ëç∑',
      'ÈÅ©ÂêàÈï∑ÊúüÂ≠∏ÁøíË®àÂäÉ'
    ]
  }
};

// üÜï ‰æùË≥¥Èóú‰øÇÂàÜÊûê
export interface SubtaskDependency {
  subtaskId: string;
  dependsOn: string[]; // ‰æùË≥¥ÁöÑÂ≠ê‰ªªÂãôIDÂàóË°®
  canStartEarly?: boolean; // ÊòØÂê¶ÂèØ‰ª•ÊèêÂâçÈñãÂßãÔºàÈÉ®ÂàÜ‰æùË≥¥Ôºâ
  minGapDays?: number; // ËàáÂâçÁΩÆ‰ªªÂãôÁöÑÊúÄÂ∞èÈñìÈöîÂ§©Êï∏
}

// üÜï Â¢ûÂº∑ÁöÑÊéíÁ®ãÈÅ∏È†Ö
interface EnhancedSchedulingOptions {
  startDate?: Date;
  startNextDay?: boolean; // üÜï ÊòØÂê¶ÂæûÈöîÂ§©ÈñãÂßã
  maxDaysToSearch?: number;
  bufferBetweenSubtasks?: number;
  respectPhaseOrder?: boolean;
  dailyMaxHours?: number | null;
  mode?: SchedulingMode; // üÜï ÊéíÁ®ãÊ®°Âºè
  respectDependencies?: boolean; // üÜï ÊòØÂê¶ËÄÉÊÖÆ‰æùË≥¥Èóú‰øÇ
  dependencies?: SubtaskDependency[]; // üÜï ‰æùË≥¥Èóú‰øÇÂÆöÁæ©
  flexibilityFactor?: number; // üÜï ÂΩàÊÄßÂõ†Â≠ê (0.1-1.0)ÔºåË∂äÈ´òË∂äÂàÜÊï£
}

export function timeToMinutes(time: string): number {
  try {
    const [hours, minutes] = time.split(":").map(Number);
    return hours * 60 + minutes;
  } catch (error) {
    console.error("Time to minutes error:", error);
    return 0;
  }
}

export function minutesToTime(minutes: number): string {
  try {
    const hours = Math.floor(minutes / 60);
    const mins = minutes % 60;
    return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}`;
  } catch (error) {
    console.error("Minutes to time error:", error);
    return "00:00";
  }
}

export function getDayOfWeek(date: Date): DayOfWeek {
  try {
    const days: DayOfWeek[] = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
    return days[date.getDay()];
  } catch (error) {
    console.error("Get day of week error:", error);
    return "monday";
  }
}

export function getDateString(date: Date): string {
  try {
    return date.toISOString().split("T")[0];
  } catch (error) {
    console.error("Get date string error:", error);
    return new Date().toISOString().split("T")[0];
  }
}

export function addDays(date: Date, days: number): Date {
  try {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  } catch (error) {
    console.error("Add days error:", error);
    return new Date();
  }
}

export function isTimeSlotAvailable(
  timeSlot: TimeSlot,
  existingTasks: ScheduledTask[],
  calendarEvents: CalendarEvent[],
  date: string
): boolean {
  try {
    const slotStart = timeToMinutes(timeSlot.start);
    const slotEnd = timeToMinutes(timeSlot.end);
    
    // Check against existing scheduled tasks
    const dayTasks = existingTasks.filter(task => task.date === date);
    for (const task of dayTasks) {
      const taskStart = timeToMinutes(task.timeSlot.start);
      const taskEnd = timeToMinutes(task.timeSlot.end);
      
      if (
        (slotStart >= taskStart && slotStart < taskEnd) ||
        (slotEnd > taskStart && slotEnd <= taskEnd) ||
        (slotStart <= taskStart && slotEnd >= taskEnd)
      ) {
        return false;
      }
    }
    
    // Check against calendar events
    for (const event of calendarEvents) {
      if (event.isAllDay) continue;
      
      const eventDate = new Date(event.start);
      if (getDateString(eventDate) !== date) continue;
      
      const eventStart = eventDate.getHours() * 60 + eventDate.getMinutes();
      const eventEnd = event.end.getHours() * 60 + event.end.getMinutes();
      
      if (
        (slotStart >= eventStart && slotStart < eventEnd) ||
        (slotEnd > eventStart && slotEnd <= eventEnd) ||
        (slotStart <= eventStart && slotEnd >= eventEnd)
      ) {
        return false;
      }
    }
    
    return true;
  } catch (error) {
    console.error("Is time slot available error:", error);
    return false;
  }
}

export function findAvailableTimeSlot(
  task: Task,
  availableTimeSlots: DayTimeSlots,
  existingTasks: ScheduledTask[],
  calendarEvents: CalendarEvent[] = [],
  startDate: Date = new Date(),
  maxDaysToSearch: number = 14
): ScheduledTask | null {
  try {
    const taskDuration = task.duration || 60; // Default to 60 minutes
    
    for (let dayOffset = 0; dayOffset < maxDaysToSearch; dayOffset++) {
      const currentDate = addDays(startDate, dayOffset);
      const dayOfWeek = getDayOfWeek(currentDate);
      const dateString = getDateString(currentDate);
      
      const daySlots = availableTimeSlots[dayOfWeek];
      if (!daySlots) continue;
      
      for (const slot of daySlots) {
        const slotDuration = timeToMinutes(slot.end) - timeToMinutes(slot.start);
        
        // Check if the task fits in this slot
        if (slotDuration >= taskDuration) {
          // Try to fit the task at the beginning of the slot
          const taskEndTime = timeToMinutes(slot.start) + taskDuration;
          const taskTimeSlot: TimeSlot = {
            start: slot.start,
            end: minutesToTime(taskEndTime),
          };
          
          if (isTimeSlotAvailable(taskTimeSlot, existingTasks, calendarEvents, dateString)) {
            return {
              taskId: task.id,
              date: dateString,
              timeSlot: taskTimeSlot,
              duration: taskDuration,
            };
          }
          
          // Try to find a smaller available window within the slot
          const slotStart = timeToMinutes(slot.start);
          const slotEnd = timeToMinutes(slot.end);
          
          for (let startTime = slotStart; startTime + taskDuration <= slotEnd; startTime += 15) {
            const endTime = startTime + taskDuration;
            const candidateSlot: TimeSlot = {
              start: minutesToTime(startTime),
              end: minutesToTime(endTime),
            };
            
            if (isTimeSlotAvailable(candidateSlot, existingTasks, calendarEvents, dateString)) {
              return {
                taskId: task.id,
                date: dateString,
                timeSlot: candidateSlot,
                duration: taskDuration,
              };
            }
          }
        }
      }
    }
    
    return null;
  } catch (error) {
    console.error("Find available time slot error:", error);
    return null;
  }
}

export function calculateTaskPriority(task: Task): number {
  try {
    let priority = 0;
    
    // Due date urgency
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      const today = new Date();
      const daysUntilDue = Math.ceil((dueDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysUntilDue <= 1) priority += 100;
      else if (daysUntilDue <= 3) priority += 50;
      else if (daysUntilDue <= 7) priority += 25;
    }
    
    // Task difficulty
    if (task.difficulty === "hard") priority += 30;
    else if (task.difficulty === "medium") priority += 20;
    else if (task.difficulty === "easy") priority += 10;
    
    // Task duration (longer tasks get higher priority to schedule early)
    if (task.duration) {
      if (task.duration >= 120) priority += 20;
      else if (task.duration >= 60) priority += 15;
      else priority += 10;
    }
    
    // Explicit priority
    if (task.priority === "high") priority += 40;
    else if (task.priority === "medium") priority += 20;
    else if (task.priority === "low") priority += 5;
    
    return priority;
  } catch (error) {
    console.error("Calculate task priority error:", error);
    return 0;
  }
}

export function scheduleMultipleTasks(
  tasks: Task[],
  availableTimeSlots: DayTimeSlots,
  existingTasks: ScheduledTask[],
  calendarEvents: CalendarEvent[] = []
): ScheduledTask[] {
  try {
    // Sort tasks by priority
    const sortedTasks = [...tasks].sort((a, b) => 
      calculateTaskPriority(b) - calculateTaskPriority(a)
    );
    
    const scheduledTasks: ScheduledTask[] = [...existingTasks];
    const newScheduledTasks: ScheduledTask[] = [];
    
    for (const task of sortedTasks) {
      // Skip if task is already scheduled
      if (scheduledTasks.some(st => st.taskId === task.id)) {
        continue;
      }
      
      const scheduledTask = findAvailableTimeSlot(
        task,
        availableTimeSlots,
        scheduledTasks,
        calendarEvents
      );
      
      if (scheduledTask) {
        scheduledTasks.push(scheduledTask);
        newScheduledTasks.push(scheduledTask);
      }
    }
    
    return newScheduledTasks;
  } catch (error) {
    console.error("Schedule multiple tasks error:", error);
    return [];
  }
}

export function rescheduleConflictingTasks(
  calendarEvents: CalendarEvent[],
  scheduledTasks: ScheduledTask[],
  availableTimeSlots: DayTimeSlots,
  tasks: Task[]
): ScheduledTask[] {
  try {
    const conflictingTasks: ScheduledTask[] = [];
    const nonConflictingTasks: ScheduledTask[] = [];
    
    // Identify conflicting tasks
    for (const scheduledTask of scheduledTasks) {
      const hasConflict = calendarEvents.some(event => {
        if (event.isAllDay) return false;
        
        const eventDate = getDateString(event.start);
        if (eventDate !== scheduledTask.date) return false;
        
        const eventStart = event.start.getHours() * 60 + event.start.getMinutes();
        const eventEnd = event.end.getHours() * 60 + event.end.getMinutes();
        const taskStart = timeToMinutes(scheduledTask.timeSlot.start);
        const taskEnd = timeToMinutes(scheduledTask.timeSlot.end);
        
        return (
          (taskStart >= eventStart && taskStart < eventEnd) ||
          (taskEnd > eventStart && taskEnd <= eventEnd) ||
          (taskStart <= eventStart && taskEnd >= eventEnd)
        );
      });
      
      if (hasConflict) {
        conflictingTasks.push(scheduledTask);
      } else {
        nonConflictingTasks.push(scheduledTask);
      }
    }
    
    // Reschedule conflicting tasks
    const tasksToReschedule = conflictingTasks
      .map(st => tasks.find(t => t.id === st.taskId))
      .filter(Boolean) as Task[];
    
    const rescheduledTasks = scheduleMultipleTasks(
      tasksToReschedule,
      availableTimeSlots,
      nonConflictingTasks,
      calendarEvents
    );
    
    return [...nonConflictingTasks, ...rescheduledTasks];
  } catch (error) {
    console.error("Reschedule conflicting tasks error:", error);
    return scheduledTasks;
  }
}

export interface SubtaskSchedule {
  subtaskId: string;
  subtaskTitle: string;
  date: string;
  timeSlot: TimeSlot;
  duration: number;
  phase?: string;
  order: number;
  // üÜï ÊôÇÈñìÂàáÂâ≤ÊîØÊè¥
  segmentIndex?: number; // ÁâáÊÆµÂ∫èËôüÔºàÂæû 1 ÈñãÂßãÔºâ
  totalSegments?: number; // Á∏ΩÁâáÊÆµÊï∏
  isSegmented?: boolean; // ÊòØÂê¶ÁÇ∫ÂàáÂâ≤ÁöÑÁâáÊÆµ
  remainingDuration?: number; // Ââ©È§òÁ∏ΩÊôÇÈï∑
}

export interface SchedulingResult {
  success: boolean;
  scheduledSubtasks: SubtaskSchedule[];
  unscheduledSubtasks: string[];
  message: string;
  totalScheduledMinutes: number;
  completionDate?: string;
}

/**
 * Schedule subtasks based on their estimated duration and available time slots
 * Ensures all subtasks are completed before the due date if provided
 */
export function scheduleSubtasks(
  task: Task,
  availableTimeSlots: DayTimeSlots,
  existingScheduledTasks: ScheduledTask[],
  calendarEvents: CalendarEvent[] = [],
  options: EnhancedSchedulingOptions = {}
): SchedulingResult {
  try {
    const {
      startDate = new Date(),
      startNextDay = true, // üÜï È†êË®≠ÂæûÈöîÂ§©ÈñãÂßã
      maxDaysToSearch = 90,
      bufferBetweenSubtasks = 5,
      respectPhaseOrder = false,
      dailyMaxHours = null,
      mode = 'flexible', // üÜï È†êË®≠‰ΩøÁî®ÂΩàÊÄßÊ®°Âºè
      respectDependencies = true, // üÜï È†êË®≠ËÄÉÊÖÆ‰æùË≥¥Èóú‰øÇ
      dependencies = [], // üÜï ‰æùË≥¥Èóú‰øÇÂàóË°®
      flexibilityFactor = 0.7 // üÜï ÂΩàÊÄßÂõ†Â≠êÔºå0.5=Âπ≥Ë°°Ôºå1.0=ÊúÄÂàÜÊï£
    } = options;

    // üÜï Ë®àÁÆóÂØ¶ÈöõÈñãÂßãÊó•Êúü
    const actualStartDate = new Date(startDate);
    if (startNextDay) {
      actualStartDate.setDate(actualStartDate.getDate() + 1);
      actualStartDate.setHours(0, 0, 0, 0); // ÈáçÁΩÆÂà∞ÈöîÂ§©ÁöÑÈñãÂßã
    }

    // Validate inputs
    if (!task.subtasks || task.subtasks.length === 0) {
      return {
        success: false,
        scheduledSubtasks: [],
        unscheduledSubtasks: [],
        message: "No subtasks to schedule",
        totalScheduledMinutes: 0
      };
    }

    // üÜï Ë®àÁÆóÊúâÊïàÊà™Ê≠¢ÊúüÈôêÔºåÂü∫ÊñºÂØ¶ÈöõÈñãÂßãÊó•Êúü
    let effectiveMaxDays = maxDaysToSearch;
    if (task.dueDate) {
      const dueDate = new Date(task.dueDate);
      const daysUntilDue = Math.ceil((dueDate.getTime() - actualStartDate.getTime()) / (1000 * 60 * 60 * 24));
      
      // üÜï Âè™Âú®Êà™Ê≠¢Êó•ÊúüÁúüÁöÑÂ∞èÊñºÊúÄÂ§ßÊêúÁ¥¢Â§©Êï∏ÊôÇÊâçÈôêÂà∂ÔºåÂê¶Ââá‰ΩøÁî®ÂÆåÊï¥ÁöÑÊêúÁ¥¢ÁØÑÂúç
      // ÈÄôÊ®£ÂèØ‰ª•ÂÖÖÂàÜÂà©Áî®Áî®Êà∂ÁöÑÈÄ±ÊúüÊÄßÊôÇÈñìË°®ÔºàÂ¶ÇÊØèÈÄ±48Â∞èÊôÇÔºâ
      effectiveMaxDays = Math.min(maxDaysToSearch, Math.max(7, daysUntilDue));
      
      // üÜï Â¶ÇÊûúÊà™Ê≠¢Êó•ÊúüÂæàÂØ¨È¨ÜÔºå‰øùÊåÅ‰ΩøÁî®ÂÆåÊï¥ÁöÑÊêúÁ¥¢ÁØÑÂúç‰ª•Êõ¥Â•ΩÂàÜÊï£‰ªªÂãô
      if (daysUntilDue > maxDaysToSearch * 0.8) {
        effectiveMaxDays = maxDaysToSearch;
      }
    }

    // üÜï ÂàùÂßãÂåñÂ≠ê‰ªªÂãôÈÄ≤Â∫¶ËøΩËπ§‰∏¶ÈÅéÊøæÊú™ÂÆåÊàêÁöÑÂ≠ê‰ªªÂãô
    const initializedSubtasks = (task.subtasks || []).map(subtask => {
      // üîß ÈóúÈçµ‰øÆÂæ©ÔºöÂú®ÂàùÂßãÂåñÂâçÂÖàÈ©óË≠âÂíå‰øÆÊ≠£ÊôÇÈï∑
      const validation = validateAndProtectSubtaskDuration(subtask);
      if (!validation.isValid) {
        console.warn(`üîß Auto-correcting duration for subtask ${subtask.id}:`, validation.issues);
      }
      
      // ‰ΩøÁî®‰øÆÊ≠£ÂæåÁöÑÂ≠ê‰ªªÂãôÈÄ≤Ë°åÂàùÂßãÂåñ
      return initializeSubtaskProgress(validation.correctedSubtask);
    });
    
    const incompleteSubtasks = initializedSubtasks.filter(subtask => 
      getSubtaskRemainingTime(subtask) > 0
    );

    // üÜï ‰æùË≥¥Èóú‰øÇÂàÜÊûê
    const dependencyMap = new Map<string, string[]>();
    const reverseDependencyMap = new Map<string, string[]>();
    
    dependencies.forEach(dep => {
      dependencyMap.set(dep.subtaskId, dep.dependsOn);
      dep.dependsOn.forEach(prereq => {
        if (!reverseDependencyMap.has(prereq)) {
          reverseDependencyMap.set(prereq, []);
        }
        reverseDependencyMap.get(prereq)!.push(dep.subtaskId);
      });
    });

    // üÜï ÊãìÊí≤ÊéíÂ∫è‰ª•ËôïÁêÜ‰æùË≥¥Èóú‰øÇ
    const getTopologicalOrder = (subtasks: EnhancedSubtask[]) => {
      if (!respectDependencies || dependencies.length === 0) {
        return subtasks; // Â¶ÇÊûú‰∏çËÄÉÊÖÆ‰æùË≥¥Èóú‰øÇÔºåÁõ¥Êé•ËøîÂõû
      }

      const visited = new Set<string>();
      const visiting = new Set<string>();
      const result: EnhancedSubtask[] = [];

      const visit = (subtaskId: string) => {
        if (visiting.has(subtaskId)) {
          console.warn(`Ê™¢Ê∏¨Âà∞Âæ™Áí∞‰æùË≥¥: ${subtaskId}`);
          return;
        }
        if (visited.has(subtaskId)) return;

        visiting.add(subtaskId);
        const deps = dependencyMap.get(subtaskId) || [];
        deps.forEach(depId => visit(depId));
        visiting.delete(subtaskId);
        visited.add(subtaskId);

        const subtask = subtasks.find(s => s.id === subtaskId);
        if (subtask) result.push(subtask);
      };

      subtasks.forEach(subtask => visit(subtask.id));
      
      // Ê∑ªÂä†Ê≤íÊúâ‰æùË≥¥Èóú‰øÇÁöÑÂ≠ê‰ªªÂãô
      subtasks.forEach(subtask => {
        if (!result.find(s => s.id === subtask.id)) {
          result.push(subtask);
        }
      });

      return result;
    };

    // üÜï Ê®°ÂºèÁâπÂÆöÁöÑÊéíÂ∫èÈÇèËºØ
    const applyModeSpecificSorting = (subtasks: EnhancedSubtask[]) => {
      if (mode === 'strict') {
        // Âö¥Ê†ºÊ®°ÂºèÔºöÂÑ™ÂÖàÂÆâÊéíÈï∑ÊôÇÈñì‰ªªÂãôÔºåÊåâÂâ©È§òÊôÇÈñìÈôçÂ∫è
        return subtasks.sort((a, b) => {
          const aRemaining = getSubtaskRemainingTime(a);
          const bRemaining = getSubtaskRemainingTime(b);
          return bRemaining - aRemaining; // ÈôçÂ∫è
        });
      } else {
        // ÂΩàÊÄßÊ®°ÂºèÔºöÊ∑∑ÂêàÊéíÂ∫èÔºåÈÅøÂÖçÈÄ£Á∫åÂÆâÊéíÂêåÈ°ûÂûã‰ªªÂãô
        return subtasks.sort((a, b) => {
          // 1. ÊåâÈöéÊÆµÂàÜÊï£
          if (a.phase !== b.phase) {
            const phaseOrder = ["knowledge", "practice", "application", "reflection", "output", "review"];
            const aIndex = phaseOrder.indexOf(a.phase || "");
            const bIndex = phaseOrder.indexOf(b.phase || "");
            if (aIndex !== -1 && bIndex !== -1) {
              return aIndex - bIndex;
            }
          }
          
          // 2. ÊåâÈõ£Â∫¶‰∫§Êõø
          const difficultyOrder = { "easy": 1, "medium": 2, "hard": 3 };
          const aDifficulty = difficultyOrder[a.difficulty as keyof typeof difficultyOrder] || 2;
          const bDifficulty = difficultyOrder[b.difficulty as keyof typeof difficultyOrder] || 2;
          
          // 3. ÊôÇÈñìÈï∑Â∫¶Âπ≥Ë°°
          const aRemaining = getSubtaskRemainingTime(a);
          const bRemaining = getSubtaskRemainingTime(b);
          
          return aDifficulty - bDifficulty || aRemaining - bRemaining;
        });
      }
    };

    // ÊáâÁî®ÊéíÂ∫èÈÇèËºØ
    const dependencyOrderedSubtasks = getTopologicalOrder(incompleteSubtasks);
    const sortedSubtasks = applyModeSpecificSorting(dependencyOrderedSubtasks);

    // Track scheduled subtasks and daily usage
    const scheduledSubtasks: SubtaskSchedule[] = [];
    const unscheduledSubtasks: string[] = [];
    const dailyUsage: Record<string, number> = {}; // date -> minutes used
    let totalScheduledMinutes = 0;

    // Create a copy of existing scheduled tasks to track conflicts
    const allScheduledSlots: ScheduledTask[] = [...existingScheduledTasks];

    // üÜï È†êÂÖàË®àÁÆóÊâÄÊúâÂèØÁî®ÊôÇÈñìÁ™óÂè£‰ª•ÊèêÈ´òÊïàÁéáÔºå‰ΩøÁî®ÂØ¶ÈöõÈñãÂßãÊó•Êúü
    const allAvailableWindows = precomputeAvailableWindows(
      availableTimeSlots,
      allScheduledSlots,
      calendarEvents,
      actualStartDate,
      effectiveMaxDays
    );

    // üÜï Â¢ûÂº∑ÁöÑÂ≠ê‰ªªÂãôÊéíÁ®ãÈÇèËºØÔºåÊîØÊè¥Êõ¥ÈùàÊ¥ªÁöÑÊôÇÈñìÂàáÂâ≤ÂíåÈÄ≤Â∫¶Ë®òÈåÑ
    for (const subtask of sortedSubtasks) {
      const remainingTime = getSubtaskRemainingTime(subtask);
      if (remainingTime <= 0) continue; // Skip completed subtasks
      
      let totalScheduledForSubtask = 0;
      let segmentIndex = 1;
      const subtaskSegments: SubtaskSchedule[] = [];
      
      // üÜï ÂãïÊÖãË™øÊï¥ÊúÄÂ∞èÊúÉË©±ÊôÇÈï∑ - Êõ¥ÈùàÊ¥ªÁöÑË®≠ÂÆö
      const baseMinSessionDuration = subtask.minSessionDuration || 5; // üÜï Èôç‰ΩéÊúÄÂ∞èÊúÉË©±ÊôÇÈï∑Âà∞5ÂàÜÈêò
      const maxSessionDuration = subtask.maxSessionDuration || 180; // üÜï Â¢ûÂä†ÊúÄÂ§ßÊúÉË©±ÊôÇÈï∑Âà∞3Â∞èÊôÇ

      // üÜï Â§öËº™ÊéíÁ®ãÁ≠ñÁï• - ÈÄêËº™Èôç‰ΩéË¶ÅÊ±Ç‰ª•ÊèêÈ´òÊàêÂäüÁéá
      for (let round = 1; round <= 4 && totalScheduledForSubtask < remainingTime; round++) {
        let currentMinSession: number;
        
        switch (round) {
          case 1:
            currentMinSession = baseMinSessionDuration; // ÂéüÂßãË¶ÅÊ±Ç
            break;
          case 2:
            currentMinSession = Math.max(15, baseMinSessionDuration - 10); // Èôç‰Ωé10ÂàÜÈêò
            break;
          case 3:
            currentMinSession = Math.max(10, baseMinSessionDuration - 15); // Èôç‰Ωé15ÂàÜÈêò
            break;
          case 4:
            currentMinSession = Math.max(5, baseMinSessionDuration - 20); // ÊúÄ‰Ωé5ÂàÜÈêò
            break;
          default:
            currentMinSession = baseMinSessionDuration;
        }

        // üÜï Ê®°ÂºèÁâπÂÆöÁöÑÊôÇÈñìÁ™óÂè£ÈÅ∏ÊìáÈÇèËºØ
        const availableWindowsForRound = allAvailableWindows.filter(window => {
          const windowDuration = timeToMinutes(window.window.end) - timeToMinutes(window.window.start);
          return windowDuration >= currentMinSession;
        }).sort((a, b) => {
          const aDuration = timeToMinutes(a.window.end) - timeToMinutes(a.window.start);
          const bDuration = timeToMinutes(b.window.end) - timeToMinutes(b.window.start);
          
          if (mode === 'strict') {
            // Âö¥Ê†ºÊ®°ÂºèÔºöÂÑ™ÂÖàÈÅ∏ÊìáÊúÄÊó©ÁöÑÊôÇÈñìÂíåÊúÄÂ§ßÁöÑÁ™óÂè£
            const aDate = new Date(a.date);
            const bDate = new Date(b.date);
            
            // 1. ÊåâÊó•ÊúüÊéíÂ∫èÔºàË∂äÊó©Ë∂äÂ•ΩÔºâ
            if (aDate.getTime() !== bDate.getTime()) {
              return aDate.getTime() - bDate.getTime();
            }
            
            // 2. Âêå‰∏ÄÂ§©ÂÖßÊåâÁ™óÂè£Â§ßÂ∞èÊéíÂ∫èÔºàË∂äÂ§ßË∂äÂ•ΩÔºâ
            return bDuration - aDuration;
          } else {
            // ÂΩàÊÄßÊ®°ÂºèÔºöÂàÜÊï£ÊéíÁ®ãÔºåÈÅøÂÖçÈÅéÂ∫¶ÂØÜÈõÜ
            const aDate = new Date(a.date);
            const bDate = new Date(b.date);
            
            // Ë®àÁÆóËàáÂ∑≤ÊéíÁ®ã‰ªªÂãôÁöÑÊôÇÈñìË∑ùÈõ¢ÔºåÂÑ™ÂÖàÈÅ∏ÊìáËºÉÂàÜÊï£ÁöÑÊôÇÈñì
            const getTimeDistanceScore = (date: string) => {
              const existingTasksOnDate = scheduledSubtasks.filter(s => s.date === date).length;
              const daysSinceStart = Math.floor((new Date(date).getTime() - actualStartDate.getTime()) / (1000 * 60 * 60 * 24));
              
              // Âü∫ÊñºÂΩàÊÄßÂõ†Â≠êË®àÁÆóÂàÜÊï£Á®ãÂ∫¶
              const dispersalBonus = Math.floor(daysSinceStart * flexibilityFactor) * 10;
              const densityPenalty = existingTasksOnDate * 5;
              
              return dispersalBonus - densityPenalty;
            };
            
            const aScore = getTimeDistanceScore(a.date);
            const bScore = getTimeDistanceScore(b.date);
            
            // 1. ÊåâÂàÜÊï£ÂæóÂàÜÊéíÂ∫è
            if (Math.abs(aScore - bScore) > 5) {
              return bScore - aScore; // ÂàÜÊï∏Ë∂äÈ´òË∂äÂ•Ω
            }
            
            // 2. ÈÅ©ÂêàÂ∫¶ÊéíÂ∫èÔºàÂâ©È§òÊôÇÈñìËºÉÂ∞ëÊôÇÂÑ™ÂÖàÈÅ∏ÊìáÂâõÂ•ΩÂ§ßÂ∞èÁöÑÁ™óÂè£Ôºâ
            if (remainingTime - totalScheduledForSubtask <= maxSessionDuration) {
              const aFit = Math.abs(aDuration - (remainingTime - totalScheduledForSubtask));
              const bFit = Math.abs(bDuration - (remainingTime - totalScheduledForSubtask));
              return aFit - bFit;
            }
            
            // 3. ÊôÇÈñìÂπ≥Ë°°ÔºàÈÅøÂÖçÈÅéÈï∑ÊàñÈÅéÁü≠ÁöÑÊúÉË©±Ôºâ
            const idealDuration = Math.min(90, Math.max(30, remainingTime - totalScheduledForSubtask));
            const aBalance = Math.abs(aDuration - idealDuration);
            const bBalance = Math.abs(bDuration - idealDuration);
            return aBalance - bBalance;
          }
        });

        // Try to schedule this subtask using available windows
        for (const windowInfo of availableWindowsForRound) {
          if (totalScheduledForSubtask >= remainingTime) break;
          
          const { date, dayOfWeek, window } = windowInfo;
          
          // Check if this window has been used by current scheduling
          const isWindowAvailable = !allScheduledSlots.some(slot => 
            slot.date === date && 
            timeToMinutes(slot.timeSlot.start) < timeToMinutes(window.end) &&
            timeToMinutes(slot.timeSlot.end) > timeToMinutes(window.start)
          );
          
          if (!isWindowAvailable) continue;
          
          // Check daily limit (if enabled)
          const dailyUsedMinutes = dailyUsage[date] || 0;
          if (dailyMaxHours !== null && dailyUsedMinutes >= dailyMaxHours * 60) {
            continue;
          }
          
          const windowDuration = timeToMinutes(window.end) - timeToMinutes(window.start);
          
          // üÜï Êõ¥Êô∫ËÉΩÁöÑÊôÇÈñìÂàÜÈÖçÈÇèËºØ
          if (windowDuration >= currentMinSession) {
            const remainingToSchedule = remainingTime - totalScheduledForSubtask;
            
            // üÜï ‰ΩøÁî® getNextSessionDuration Êô∫ËÉΩË®àÁÆóÊúÄ‰Ω≥ÊúÉË©±ÊôÇÈï∑
            const idealSessionDuration = getNextSessionDuration(
              { ...subtask, remainingTime: remainingToSchedule }, 
              windowDuration - bufferBetweenSubtasks
            );
            
            // Á¢∫‰øùÊúÉË©±ÊôÇÈï∑ÊªøË∂≥Áï∂ÂâçËº™Ê¨°ÁöÑÊúÄÂ∞èË¶ÅÊ±Ç
            const actualSessionDuration = Math.max(
              Math.min(idealSessionDuration, remainingToSchedule),
              round <= 2 ? currentMinSession : Math.min(currentMinSession, remainingToSchedule)
            );
            
            // üÜï Êõ¥ÂØ¨È¨ÜÁöÑÊéíÁ®ãÊ¢ù‰ª∂ - ÂÖÅË®±ËºÉÁü≠ÁöÑÊúÄÁµÇÊúÉË©±
            const canScheduleSession = actualSessionDuration >= currentMinSession || 
              (remainingToSchedule <= currentMinSession && actualSessionDuration >= Math.min(5, remainingToSchedule)) ||
              (round >= 3 && actualSessionDuration >= 5); // Á¨¨3Ëº™Âèä‰ª•ÂæåÂÖÅË®±5ÂàÜÈêòÁöÑÁü≠ÊúÉË©±
            
            if (canScheduleSession) {
              // Check daily limit constraint
              let canScheduleDaily = true;
              if (dailyMaxHours !== null) {
                const remainingDailyMinutes = (dailyMaxHours * 60) - dailyUsedMinutes;
                canScheduleDaily = actualSessionDuration <= remainingDailyMinutes;
              }
              
              if (canScheduleDaily) {
                // Schedule this segment
                const subtaskTimeSlot: TimeSlot = {
                  start: window.start,
                  end: minutesToTime(timeToMinutes(window.start) + actualSessionDuration)
                };

                // üÜï Êô∫ËÉΩÂà§Êñ∑ÊòØÂê¶ÁÇ∫ÂàÜÊÆµ‰ªªÂãô
                const willBeSegmented = (remainingTime > maxSessionDuration) || 
                  (segmentIndex > 1) || 
                  (remainingTime - actualSessionDuration > 0 && remainingTime - actualSessionDuration >= currentMinSession);
                
                const subtaskSchedule: SubtaskSchedule = {
                  subtaskId: subtask.id,
                  subtaskTitle: subtask.title || subtask.text,
                  date: date,
                  timeSlot: subtaskTimeSlot,
                  duration: actualSessionDuration,
                  phase: subtask.phase,
                  order: subtask.order,
                  // üÜï Â¢ûÂº∑ÁöÑÊôÇÈñìÂàáÂâ≤Ë≥áË®ä
                  segmentIndex: willBeSegmented ? segmentIndex : undefined,
                  totalSegments: undefined, // Á®çÂæåË®àÁÆó
                  isSegmented: willBeSegmented,
                  remainingDuration: remainingTime - totalScheduledForSubtask - actualSessionDuration
                };

                subtaskSegments.push(subtaskSchedule);
                
                // Update tracking
                const taskIdForSlot = willBeSegmented 
                  ? `${task.id}_${subtask.id}_segment_${segmentIndex}`
                  : `${task.id}_${subtask.id}`;
                
                allScheduledSlots.push({
                  taskId: taskIdForSlot,
                  date: date,
                  timeSlot: subtaskTimeSlot,
                  duration: actualSessionDuration
                });
                
                dailyUsage[date] = (dailyUsage[date] || 0) + actualSessionDuration;
                totalScheduledForSubtask += actualSessionDuration;
                totalScheduledMinutes += actualSessionDuration;
                segmentIndex++;
                
                // üÜï Â¶ÇÊûúÂ∑≤ÂÆåÊàêÂ≠ê‰ªªÂãôÊéíÁ®ãÔºåË∑≥Âá∫ÊâÄÊúâÂæ™Áí∞
                if (totalScheduledForSubtask >= remainingTime) {
                  break;
                }
              }
            }
          }
        }
        
        // üÜï Â¶ÇÊûúÈÄôËº™ÊàêÂäüÊéíÁ®ã‰∫Ü‰∏Ä‰∫õÊôÇÈñìÔºåÊ™¢Êü•ÊòØÂê¶ÂèØ‰ª•ÁπºÁ∫å‰∏ã‰∏ÄËº™
        if (totalScheduledForSubtask > 0) {
          const successRate = totalScheduledForSubtask / remainingTime;
          // Â¶ÇÊûúÂ∑≤ÊéíÁ®ãË∂ÖÈÅé50%ÊàñÂÆåÂÖ®ÊéíÁ®ãÔºåÂ∞±‰∏çÈúÄË¶ÅÈôç‰ΩéË¶ÅÊ±ÇÁπºÁ∫å‰∏ã‰∏ÄËº™
          if (successRate >= 0.5 || totalScheduledForSubtask >= remainingTime) {
            break;
          }
        }
      }

      // üÜï Êõ¥Êñ∞Á∏ΩÁâáÊÆµÊï∏ÂíåÂàÜÊÆµ‰ø°ÊÅØ
      if (subtaskSegments.length > 1) {
        subtaskSegments.forEach(segment => {
          segment.totalSegments = subtaskSegments.length;
          segment.isSegmented = true;
        });
      } else if (subtaskSegments.length === 1) {
        // ÂñÆÂÄãÁâáÊÆµÁöÑÊÉÖÊ≥Å
        subtaskSegments[0].isSegmented = false;
        subtaskSegments[0].segmentIndex = undefined;
        subtaskSegments[0].totalSegments = undefined;
      }

      // Add segments to scheduled subtasks or mark as unscheduled
      if (subtaskSegments.length > 0 && totalScheduledForSubtask > 0) {
        scheduledSubtasks.push(...subtaskSegments);
        
        // üîß ‰øÆÂæ©ÔºöÊ≠£Á¢∫Ë®òÈåÑÂéüÂßãÊôÇÈï∑ËàáÊéíÁ®ãÊôÇÈï∑ÁöÑÂ∑ÆÁï∞
        if (totalScheduledForSubtask < remainingTime) {
          const originalDuration = getSubtaskOriginalDuration(subtask);
          console.warn(`‚ö†Ô∏è Duration mismatch: scheduled=${totalScheduledForSubtask}min, original=${originalDuration}min for subtask ${subtask.id}`);
          console.warn(`Subtask ${subtask.id} partially scheduled: ${totalScheduledForSubtask}/${remainingTime} minutes remaining`);
        }
      } else {
        unscheduledSubtasks.push(subtask.id);
      }
    }

    // Determine completion date
    let completionDate: string | undefined;
    if (scheduledSubtasks.length > 0) {
      const sortedByDate = scheduledSubtasks.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
      completionDate = sortedByDate[sortedByDate.length - 1].date;
    }

    // üÜï ÊîπÈÄ≤ÁöÑÁµêÊûúË®äÊÅØÁîüÊàê - Êõ¥Ë©≥Á¥∞ÁöÑÊéíÁ®ãÂàÜÊûê
    let message = "";
    const totalSubtasks = sortedSubtasks.length;
    const scheduledSubtaskIds = new Set(scheduledSubtasks.map(s => s.subtaskId));
    const actualScheduledSubtasks = scheduledSubtaskIds.size;
    const partiallyScheduledSubtasks = Array.from(scheduledSubtaskIds).filter(subtaskId => {
      const subtask = sortedSubtasks.find(s => s.id === subtaskId);
      if (!subtask) return false;
      
      const totalScheduledTime = scheduledSubtasks
        .filter(s => s.subtaskId === subtaskId)
        .reduce((sum, s) => sum + s.duration, 0);
      const remainingTime = getSubtaskRemainingTime(subtask);
      
      return totalScheduledTime < remainingTime;
    }).length;
    
    if (actualScheduledSubtasks === totalSubtasks && partiallyScheduledSubtasks === 0) {
      message = `üéâ ÊàêÂäüÊéíÁ®ãÊâÄÊúâ ${actualScheduledSubtasks} ÂÄãÂ≠ê‰ªªÂãô`;
      if (completionDate) {
        message += `ÔºåÈ†êË®àÊñº ${completionDate} ÂÆåÊàê`;
      }
      if (task.dueDate && completionDate) {
        const scheduledDate = new Date(completionDate);
        const dueDate = new Date(task.dueDate);
        if (scheduledDate <= dueDate) {
          const daysBefore = Math.ceil((dueDate.getTime() - scheduledDate.getTime()) / (1000 * 60 * 60 * 24));
          if (daysBefore > 0) {
            message += `ÔºàÊèêÂâç ${daysBefore} Â§©ÂÆåÊàêÔºâ`;
          }
        }
      }
    } else if (actualScheduledSubtasks > 0) {
      const scheduledSegments = scheduledSubtasks.length;
      message = `‚úÖ Â∑≤ÊéíÁ®ã ${actualScheduledSubtasks} / ${totalSubtasks} ÂÄãÂ≠ê‰ªªÂãô`;
      
      if (scheduledSegments > actualScheduledSubtasks) {
        message += `ÔºåÂàÜ‰ΩàÂú® ${scheduledSegments} ÂÄãÊôÇÈñìÊÆµ‰∏≠`;
      }
      
      if (partiallyScheduledSubtasks > 0) {
        message += `ÔºàÂÖ∂‰∏≠ ${partiallyScheduledSubtasks} ÂÄãÈÉ®ÂàÜÊéíÁ®ãÔºâ`;
      }
      
      if (unscheduledSubtasks.length > 0) {
        message += `\n\n‚ö†Ô∏è ÁÑ°Ê≥ïÊéíÁ®ã ${unscheduledSubtasks.length} ÂÄãÂ≠ê‰ªªÂãô`;
        if (task.dueDate) {
          message += `ÔºàÊà™Ê≠¢Êó•ÊúüÈôêÂà∂Ôºâ`;
        }
        
        // üÜï Êèê‰æõÂÖ∑È´îÁöÑÊîπÈÄ≤Âª∫Ë≠∞
        const totalUnscheduledTime = unscheduledSubtasks.reduce((total, subtaskId) => {
          const subtask = sortedSubtasks.find(s => s.id === subtaskId);
          return total + (subtask ? getSubtaskRemainingTime(subtask) : 0);
        }, 0);
        
        const hoursNeeded = Math.round(totalUnscheduledTime / 60 * 10) / 10;
        message += `\nÈúÄË¶ÅÈ°çÂ§ñ ${hoursNeeded} Â∞èÊôÇÁöÑÂ≠∏ÁøíÊôÇÈñì`;
      }
    } else {
      message = "‚ùå ÁÑ°Ê≥ïÊéíÁ®ã‰ªª‰ΩïÂ≠ê‰ªªÂãô\n\nË´ãÊ™¢Êü•ÊÇ®ÁöÑÂèØÁî®ÊôÇÈñìË®≠ÁΩÆÊàñÂª∂Èï∑Êà™Ê≠¢Êó•Êúü";
    }

    // üÜï Ë®àÁÆóÊéíÁ®ãÊàêÂäüÁéá
    const successRate = actualScheduledSubtasks / totalSubtasks;
    const isHighSuccess = successRate >= 0.8;

    return {
      success: actualScheduledSubtasks > 0 && isHighSuccess,
      scheduledSubtasks,
      unscheduledSubtasks,
      message,
      totalScheduledMinutes,
      completionDate
    };
  } catch (error) {
    console.error("Schedule subtasks error:", error);
    return {
      success: false,
      scheduledSubtasks: [],
      unscheduledSubtasks: task.subtasks?.map(s => s.id) || [],
      message: "ÊéíÁ®ãÁ≥ªÁµ±ÁôºÁîüÈåØË™§ÔºåË´ãÊ™¢Êü•ÊÇ®ÁöÑË®≠ÁΩÆÊàñÈáçË©¶",
      totalScheduledMinutes: 0
    };
  }
}

/**
 * üÜï È†êÂÖàË®àÁÆóÊâÄÊúâÂèØÁî®ÊôÇÈñìÁ™óÂè£‰ª•ÊèêÈ´òÊéíÁ®ãÊïàÁéá
 */
interface WindowInfo {
  date: string;
  dayOfWeek: string;
  window: TimeSlot;
  originalSlot: TimeSlot;
}

function precomputeAvailableWindows(
  availableTimeSlots: DayTimeSlots,
  existingScheduledTasks: ScheduledTask[],
  calendarEvents: CalendarEvent[],
  startDate: Date,
  maxDays: number
): WindowInfo[] {
  const allWindows: WindowInfo[] = [];
  
  for (let dayOffset = 0; dayOffset < maxDays; dayOffset++) {
    const currentDate = addDays(startDate, dayOffset);
    const dayOfWeek = getDayOfWeek(currentDate);
    const dateString = getDateString(currentDate);
    
    const daySlots = availableTimeSlots[dayOfWeek];
    if (!daySlots || daySlots.length === 0) continue;

    for (const slot of daySlots) {
      const windows = findAvailableWindows(
        slot,
        existingScheduledTasks.filter(s => s.date === dateString),
        calendarEvents.filter(e => {
          const eventDate = new Date(e.start);
          return getDateString(eventDate) === dateString;
        }),
        dateString
      );

      for (const window of windows) {
        allWindows.push({
          date: dateString,
          dayOfWeek,
          window,
          originalSlot: slot
        });
      }
    }
  }
  
  // üÜï ÊåâÁ™óÂè£Â§ßÂ∞èÊéíÂ∫èÔºåÂÑ™ÂÖà‰ΩøÁî®ËºÉÂ§ßÁöÑÊôÇÈñìÁ™óÂè£
  return allWindows.sort((a, b) => {
    const aDuration = timeToMinutes(a.window.end) - timeToMinutes(a.window.start);
    const bDuration = timeToMinutes(b.window.end) - timeToMinutes(b.window.start);
    return bDuration - aDuration; // Â§ßÁ™óÂè£ÂÑ™ÂÖà
  });
}

/**
 * Find available time windows within a time slot
 */
function findAvailableWindows(
  slot: TimeSlot,
  existingTasks: ScheduledTask[],
  calendarEvents: CalendarEvent[],
  date: string
): TimeSlot[] {
  try {
    const windows: TimeSlot[] = [];
    const slotStart = timeToMinutes(slot.start);
    const slotEnd = timeToMinutes(slot.end);
    
    // Collect all occupied time ranges
    const occupiedRanges: Array<{ start: number; end: number }> = [];
    
    // Add existing tasks
    existingTasks.forEach(task => {
      occupiedRanges.push({
        start: timeToMinutes(task.timeSlot.start),
        end: timeToMinutes(task.timeSlot.end)
      });
    });
    
    // Add calendar events
    calendarEvents.forEach(event => {
      if (!event.isAllDay) {
        const eventStart = event.start.getHours() * 60 + event.start.getMinutes();
        const eventEnd = event.end.getHours() * 60 + event.end.getMinutes();
        occupiedRanges.push({ start: eventStart, end: eventEnd });
      }
    });
    
    // Sort occupied ranges by start time
    occupiedRanges.sort((a, b) => a.start - b.start);
    
    // Merge overlapping ranges
    const mergedRanges: Array<{ start: number; end: number }> = [];
    occupiedRanges.forEach(range => {
      if (mergedRanges.length === 0) {
        mergedRanges.push(range);
      } else {
        const last = mergedRanges[mergedRanges.length - 1];
        if (range.start <= last.end) {
          last.end = Math.max(last.end, range.end);
        } else {
          mergedRanges.push(range);
        }
      }
    });
    
    // Find free windows
    let currentStart = slotStart;
    
    mergedRanges.forEach(range => {
      // Only consider ranges that overlap with our slot
      if (range.end > slotStart && range.start < slotEnd) {
        const windowStart = Math.max(currentStart, slotStart);
        const windowEnd = Math.min(range.start, slotEnd);
        
        if (windowEnd > windowStart) {
          windows.push({
            start: minutesToTime(windowStart),
            end: minutesToTime(windowEnd)
          });
        }
        
        currentStart = Math.max(range.end, currentStart);
      }
    });
    
    // Add final window if there's space
    if (currentStart < slotEnd) {
      windows.push({
        start: minutesToTime(currentStart),
        end: minutesToTime(slotEnd)
      });
    }
    
    return windows;
  } catch (error) {
    console.error("Find available windows error:", error);
    return [];
  }
}

/**
 * Convert subtask schedules to scheduled tasks for storage
 */
export function convertSubtaskSchedulesToTasks(
  taskId: string,
  subtaskSchedules: SubtaskSchedule[]
): ScheduledTask[] {
  return subtaskSchedules.map(schedule => {
    // üÜï ‰øÆÊ≠£ÔºöÊ≠£Á¢∫ËôïÁêÜÂ≠ê‰ªªÂãôÁâáÊÆµÁöÑ ID Ê†ºÂºèÔºåÈÅøÂÖç ID Ë°ùÁ™Å
    let scheduledTaskId: string;
    
    if (schedule.isSegmented && schedule.segmentIndex && schedule.totalSegments) {
      // ÂàÜÂâ≤ÁöÑÂ≠ê‰ªªÂãôÁâáÊÆµÔºö${taskId}_${subtaskId}_segment_${segmentIndex}
      scheduledTaskId = `${taskId}_${schedule.subtaskId}_segment_${schedule.segmentIndex}`;
    } else {
      // ÊôÆÈÄöÂ≠ê‰ªªÂãôÔºö${taskId}_${subtaskId}
      scheduledTaskId = `${taskId}_${schedule.subtaskId}`;
    }
    
    return {
      taskId: scheduledTaskId,
      date: schedule.date,
      timeSlot: schedule.timeSlot,
      duration: schedule.duration
    };
  });
}

/**
 * üÜï ÊéíÁ®ãÂèØË°åÊÄßÂàÜÊûêÂíåÈ†êÊ™¢Êü•
 */
export interface SchedulingFeasibilityAnalysis {
  isFeasible: boolean;
  totalRequiredTime: number; // Á∏ΩÈúÄË¶ÅÊôÇÈñìÔºàÂàÜÈêòÔºâ
  totalAvailableTime: number; // Á∏ΩÂèØÁî®ÊôÇÈñìÔºàÂàÜÈêòÔºâ
  timeDeficit: number; // ÊôÇÈñì‰∏çË∂≥ÈáèÔºàÂàÜÈêòÔºâ
  issues: SchedulingIssue[];
  suggestions: SchedulingSuggestion[];
  canProceedWithAutoScheduling: boolean;
}

export interface SchedulingIssue {
  type: 'insufficient_time' | 'subtask_too_long' | 'deadline_too_tight' | 'no_suitable_slots';
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  affectedSubtasks?: string[];
}

export interface SchedulingSuggestion {
  type: 'extend_deadline' | 'reduce_subtasks' | 'reduce_duration' | 'increase_availability' | 'enable_splitting';
  priority: 'high' | 'medium' | 'low';
  description: string;
  actionRequired: string;
  estimatedImpact: string;
}

/**
 * üÜï ÊéíÁ®ãÂâçÂèØË°åÊÄßÂàÜÊûê - Á¢∫‰øùÁôæÂàÜÁôæÊéíÂÖ•ÊàñÊèê‰æõÂÖ∑È´îÂª∫Ë≠∞
 */
export function analyzeSchedulingFeasibility(
  task: Task,
  availableTimeSlots: DayTimeSlots,
  existingScheduledTasks: ScheduledTask[],
  calendarEvents: CalendarEvent[] = [],
  options: {
    startDate?: Date;
    maxDaysToSearch?: number;
    bufferBetweenSubtasks?: number;
    respectPhaseOrder?: boolean;
    dailyMaxHours?: number | null;
  } = {}
): SchedulingFeasibilityAnalysis {
  const {
    startDate = new Date(),
    maxDaysToSearch = 90,
    bufferBetweenSubtasks = 5,
    dailyMaxHours = null
  } = options;

  const issues: SchedulingIssue[] = [];
  const suggestions: SchedulingSuggestion[] = [];

  // Âü∫Êú¨Ê™¢Êü•
  if (!task.subtasks || task.subtasks.length === 0) {
    return {
      isFeasible: true,
      totalRequiredTime: 0,
      totalAvailableTime: 0,
      timeDeficit: 0,
      issues: [],
      suggestions: [],
      canProceedWithAutoScheduling: true
    };
  }

  // Ë®àÁÆóÁ∏ΩÈúÄË¶ÅÊôÇÈñì
  const totalRequiredTime = task.subtasks.reduce((total, subtask) => {
    // üîß ‰øÆÂæ©Ôºö‰ΩøÁî®ÂéüÂßãÈ†ê‰º∞ÊôÇÈï∑ËÄåÈùûÂèØËÉΩË¢´Â£ìÁ∏ÆÁöÑÊôÇÈï∑
    const originalDuration = getSubtaskOriginalDuration(subtask);
    const remainingTime = getSubtaskRemainingTime(subtask);
    return total + remainingTime;
  }, 0);

  // Ë®àÁÆóÊà™Ê≠¢Êó•ÊúüÈôêÂà∂
  let effectiveMaxDays = maxDaysToSearch;
  if (task.dueDate) {
    const dueDate = new Date(task.dueDate);
    const daysUntilDue = Math.ceil((dueDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
    
    // üÜï ÂÆåÂÖ®‰øÆÊ≠£ÈÇèËºØÔºöÂÖÖÂàÜÂà©Áî®Áî®Êà∂ÈÖçÁΩÆÁöÑÈÄ±ÊúüÊÄßÊôÇÈñìË°®
    // Âè™Âú®Êà™Ê≠¢Êó•ÊúüÁúüÁöÑÂæàÁ∑äËø´‰∏îÂ∞èÊñºÊêúÁ¥¢ÁØÑÂúçÊôÇÊâçÈôêÂà∂ÔºåÂê¶Ââá‰ΩøÁî®ÂÆåÊï¥ÊêúÁ¥¢ÁØÑÂúç
    effectiveMaxDays = Math.min(maxDaysToSearch, Math.max(7, daysUntilDue));
    
    // üÜï Â¶ÇÊûúÊà™Ê≠¢Êó•ÊúüÂØ¨È¨ÜÔºå‰øùÊåÅ‰ΩøÁî®ÂÆåÊï¥ÁöÑÊêúÁ¥¢ÁØÑÂúç‰ª•Êõ¥Â•ΩÂàÜÊï£‰ªªÂãô
    if (daysUntilDue > maxDaysToSearch * 0.8) {
      effectiveMaxDays = maxDaysToSearch;
    }
    
    if (daysUntilDue <= 0) {
      issues.push({
        type: 'deadline_too_tight',
        severity: 'critical',
        description: 'Êà™Ê≠¢Êó•ÊúüÂ∑≤ÈÅéÊàñÁÇ∫‰ªäÂ§©ÔºåÁÑ°Ê≥ïÈÄ≤Ë°åÊéíÁ®ã',
        affectedSubtasks: task.subtasks.map(s => s.id)
      });
      
      suggestions.push({
        type: 'extend_deadline',
        priority: 'high',
        description: 'Âª∂Èï∑‰ªªÂãôÊà™Ê≠¢Êó•Êúü',
        actionRequired: `Ë®≠ÂÆöÊà™Ê≠¢Êó•ÊúüËá≥Â∞ëÁÇ∫ÊòéÂ§©Ôºà${new Date(Date.now() + 24 * 60 * 60 * 1000).toLocaleDateString()}ÔºâÊàñÊõ¥Êôö`,
        estimatedImpact: 'Â∞á‰ΩøÊâÄÊúâÂ≠ê‰ªªÂãôÂèØ‰ª•Ë¢´ÊéíÁ®ã'
      });
    } else if (daysUntilDue <= 3) {
      issues.push({
        type: 'deadline_too_tight',
        severity: 'medium', // üÜï Èôç‰ΩéÂö¥ÈáçÁ®ãÂ∫¶ÔºåÂõ†ÁÇ∫ÊàëÂÄëÁèæÂú®ÊúÉÂà©Áî®Êõ¥Â§öÂèØÁî®ÊôÇÈñì
        description: `Êà™Ê≠¢Êó•ÊúüËºÉÁÇ∫Á∑äËø´ÔºàÂÉÖÂâ© ${daysUntilDue} Â§©Ôºâ`,
        affectedSubtasks: task.subtasks.map(s => s.id)
      });
    }
  }

  // Ë®àÁÆóÁ∏ΩÂèØÁî®ÊôÇÈñì
  const allAvailableWindows = precomputeAvailableWindows(
    availableTimeSlots,
    existingScheduledTasks,
    calendarEvents,
    startDate,
    effectiveMaxDays
  );

  let totalAvailableTime = 0;
  const dailyAvailableTime: Record<string, number> = {};

  allAvailableWindows.forEach(window => {
    const windowDuration = timeToMinutes(window.window.end) - timeToMinutes(window.window.start);
    totalAvailableTime += windowDuration;
    dailyAvailableTime[window.date] = (dailyAvailableTime[window.date] || 0) + windowDuration;
  });

  // ÊáâÁî®ÊØèÊó•ÈôêÂà∂
  if (dailyMaxHours !== null) {
    const dailyLimitMinutes = dailyMaxHours * 60;
    let adjustedTotalTime = 0;
    
    Object.values(dailyAvailableTime).forEach(dailyTime => {
      adjustedTotalTime += Math.min(dailyTime, dailyLimitMinutes);
    });
    
    totalAvailableTime = adjustedTotalTime;
  }

  const timeDeficit = Math.max(0, totalRequiredTime - totalAvailableTime);

  // ÊôÇÈñì‰∏çË∂≥ÂàÜÊûê
  if (timeDeficit > 0) {
    issues.push({
      type: 'insufficient_time',
      severity: timeDeficit > totalRequiredTime * 0.5 ? 'critical' : 'high',
      description: `ÂèØÁî®ÊôÇÈñì‰∏çË∂≥ÔºöÈúÄË¶Å ${totalRequiredTime} ÂàÜÈêòÔºå‰ΩÜÂè™Êúâ ${totalAvailableTime} ÂàÜÈêòÂèØÁî®`,
      affectedSubtasks: task.subtasks.map(s => s.id)
    });

    // Âª∫Ë≠∞Âª∂Èï∑Êà™Ê≠¢Êó•Êúü
    const additionalDaysNeeded = Math.ceil(timeDeficit / (totalAvailableTime / effectiveMaxDays));
    suggestions.push({
      type: 'extend_deadline',
      priority: 'high',
      description: 'Âª∂Èï∑‰ªªÂãôÊà™Ê≠¢Êó•Êúü',
      actionRequired: `Â∞áÊà™Ê≠¢Êó•ÊúüÂª∂Èï∑Ëá≥Â∞ë ${additionalDaysNeeded} Â§©`,
      estimatedImpact: `Â∞áÊèê‰æõÈ°çÂ§ñ ${additionalDaysNeeded * (totalAvailableTime / effectiveMaxDays)} ÂàÜÈêòÁöÑÂ≠∏ÁøíÊôÇÈñì`
    });

    // Âª∫Ë≠∞Ê∏õÂ∞ëÂ≠ê‰ªªÂãô
    const subtasksToRemove = Math.ceil(task.subtasks.length * (timeDeficit / totalRequiredTime));
    suggestions.push({
      type: 'reduce_subtasks',
      priority: 'medium',
      description: 'Ê∏õÂ∞ëÂ≠ê‰ªªÂãôÊï∏Èáè',
      actionRequired: `ËÄÉÊÖÆÁßªÈô§ ${subtasksToRemove} ÂÄãÂ≠ê‰ªªÂãôÊàñÂêà‰ΩµÈ°û‰ººÁöÑÂ≠ê‰ªªÂãô`,
      estimatedImpact: `Â∞áÊ∏õÂ∞ëÁ¥Ñ ${timeDeficit} ÂàÜÈêòÁöÑÂ≠∏ÁøíÊôÇÈñìÈúÄÊ±Ç`
    });

    // Âª∫Ë≠∞Ê∏õÂ∞ëÂ≠ê‰ªªÂãôÊôÇÈï∑
    const averageReduction = Math.ceil(timeDeficit / task.subtasks.length);
    suggestions.push({
      type: 'reduce_duration',
      priority: 'medium',
      description: 'Ê∏õÂ∞ëÂ≠ê‰ªªÂãôÂ≠∏ÁøíÊôÇÈï∑',
      actionRequired: `Â∞áÊØèÂÄãÂ≠ê‰ªªÂãôÁöÑÊôÇÈï∑Âπ≥ÂùáÊ∏õÂ∞ë ${averageReduction} ÂàÜÈêò`,
      estimatedImpact: 'Â∞á‰Ωø‰ªªÂãôËÉΩÂ§†Âú®ÁèæÊúâÊôÇÈñìÁØÑÂúçÂÖßÂÆåÊàê'
    });
  }

  // Ê™¢Êü•ÈÅéÈï∑Â≠ê‰ªªÂãô - üÜï Êõ¥Êô∫ËÉΩÁöÑÈï∑Â≠ê‰ªªÂãôÊ™¢Ê∏¨
  const maxWindowSize = Math.max(...allAvailableWindows.map(w => 
    timeToMinutes(w.window.end) - timeToMinutes(w.window.start)
  ), 0);

  // üÜï Âè™ÊúâÁúüÊ≠£ÁÑ°Ê≥ïÂàÜÂâ≤‰∏îË∂ÖÈÅéÊúÄÂ§ßÁ™óÂè£ÁöÑÂ≠ê‰ªªÂãôÊâçÁÆóÊòØÂïèÈ°å
  const longSubtasks = task.subtasks.filter(subtask => {
    const remainingTime = getSubtaskRemainingTime(subtask);
    const canBeSplit = subtask.canBeSplit !== false; // È†êË®≠ÂèØÂàÜÂâ≤
    const minSessionDuration = subtask.minSessionDuration || 5; // È†êË®≠5ÂàÜÈêò
    
    // Âè™ÊúâÁï∂Â≠ê‰ªªÂãô‰∏çÂèØÂàÜÂâ≤‰∏îÊ≤íÊúâË∂≥Â§†Â§ßÁöÑÁ™óÂè£ÊôÇÊâçÁÆóÊòØÂïèÈ°å
    return !canBeSplit && remainingTime > maxWindowSize && maxWindowSize < minSessionDuration;
  });

  if (longSubtasks.length > 0 && maxWindowSize > 0) {
    issues.push({
      type: 'subtask_too_long',
      severity: 'high',
      description: `${longSubtasks.length} ÂÄãÂ≠ê‰ªªÂãôÁöÑÊôÇÈï∑Ë∂ÖÈÅéÊúÄÂ§ßÂèØÁî®ÊôÇÈñìÁ™óÂè£Ôºà${maxWindowSize} ÂàÜÈêòÔºâ`,
      affectedSubtasks: longSubtasks.map(s => s.id)
    });

    suggestions.push({
      type: 'enable_splitting',
      priority: 'high',
      description: 'ÂïüÁî®ÊôÇÈñìÂàáÂâ≤ÂäüËÉΩ',
      actionRequired: 'ÂÖÅË®±Èï∑ÊôÇÈñìÂ≠ê‰ªªÂãôË¢´ÂàÜÂâ≤Âà∞Â§öÂÄãÂ≠∏ÁøíÊôÇÊÆµ',
      estimatedImpact: `Â∞á‰Ωø ${longSubtasks.length} ÂÄãÈï∑Â≠ê‰ªªÂãôËÉΩÂ§†Ë¢´ÊàêÂäüÊéíÁ®ã`
    });

    suggestions.push({
      type: 'reduce_duration',
      priority: 'medium',
      description: 'Ê∏õÂ∞ëÈï∑Â≠ê‰ªªÂãôÁöÑÊôÇÈï∑',
      actionRequired: `Â∞áÈï∑Â≠ê‰ªªÂãôÁöÑÊôÇÈï∑Ê∏õÂ∞ëÂà∞ ${maxWindowSize} ÂàÜÈêò‰ª•ÂÖß`,
      estimatedImpact: 'Â∞á‰ΩøÂ≠ê‰ªªÂãôËÉΩÂ§†ÂÆåÊï¥ÊéíÂÖ•ÂñÆÂÄãÊôÇÈñìÁ™óÂè£'
    });
  }

  // Ê™¢Êü•ÊòØÂê¶ÊúâË∂≥Â§†ÁöÑÊôÇÈñìÁ™óÂè£ - üÜï Êõ¥ÂêàÁêÜÁöÑÊúÄÂ∞èÊôÇÊÆµË¶ÅÊ±Ç
  const minSessionDuration = Math.min(...task.subtasks.map(s => s.minSessionDuration || 5)); // üÜï Èôç‰ΩéÂà∞5ÂàÜÈêò
  const suitableWindows = allAvailableWindows.filter(w => 
    (timeToMinutes(w.window.end) - timeToMinutes(w.window.start)) >= minSessionDuration
  );

  if (suitableWindows.length === 0) {
    issues.push({
      type: 'no_suitable_slots',
      severity: 'critical',
      description: 'Ê≤íÊúâÊâæÂà∞Á¨¶ÂêàÊúÄÂ∞èÂ≠∏ÁøíÊôÇÈï∑Ë¶ÅÊ±ÇÁöÑÊôÇÈñìÁ™óÂè£',
      affectedSubtasks: task.subtasks.map(s => s.id)
    });

    suggestions.push({
      type: 'increase_availability',
      priority: 'high',
      description: 'Â¢ûÂä†ÂèØÁî®Â≠∏ÁøíÊôÇÈñì',
      actionRequired: `Â¢ûÂä†Ëá≥Â∞ë ${minSessionDuration} ÂàÜÈêòÁöÑÈÄ£Á∫åÂ≠∏ÁøíÊôÇÊÆµ`,
      estimatedImpact: 'Â∞á‰ΩøËá™ÂãïÊéíÁ®ãÂäüËÉΩÂèØ‰ª•‰ΩøÁî®'
    });
  }

  // Âà§Êñ∑ÊòØÂê¶ÂèØ‰ª•ÈÄ≤Ë°åËá™ÂãïÊéíÁ®ã - üÜï Êõ¥ÂØ¨È¨ÜÁöÑÊ¢ù‰ª∂
  const canProceedWithAutoScheduling = issues.length === 0 || 
    issues.every(issue => issue.severity === 'low' || issue.severity === 'medium') ||
    suitableWindows.length > 0; // üÜï Âè™Ë¶ÅÊúâÂèØÁî®Á™óÂè£Â∞±ÂÖÅË®±ÂòóË©¶

  const isFeasible = timeDeficit <= totalRequiredTime * 0.2 && suitableWindows.length > 0; // üÜï ÂÖÅË®±20%ÁöÑÊôÇÈñì‰∏çË∂≥

  return {
    isFeasible,
    totalRequiredTime,
    totalAvailableTime,
    timeDeficit,
    issues,
    suggestions,
    canProceedWithAutoScheduling
  };
}

/**
 * üÜï Êô∫ËÉΩÊéíÁ®ãÂª∫Ë≠∞ÁîüÊàê
 */
export function generateSchedulingSuggestions(
  feasibilityAnalysis: SchedulingFeasibilityAnalysis,
  task: Task
): {
  shouldProceed: boolean;
  userMessage: string;
  actionableSteps: string[];
} {
  const { issues, suggestions, canProceedWithAutoScheduling, timeDeficit } = feasibilityAnalysis;

  if (canProceedWithAutoScheduling) {
    return {
      shouldProceed: true,
      userMessage: "ÊâÄÊúâÂ≠ê‰ªªÂãôÈÉΩÂèØ‰ª•ÊàêÂäüÊéíÂÖ•ÊÇ®ÁöÑÂ≠∏ÁøíÊôÇÈñìË°®‰∏≠„ÄÇ",
      actionableSteps: []
    };
  }

  const criticalIssues = issues.filter(i => i.severity === 'critical');
  const highIssues = issues.filter(i => i.severity === 'high');

  let userMessage = "‚ö†Ô∏è Ëá™ÂãïÊéíÁ®ãÈÅáÂà∞ÂïèÈ°åÔºåÁÑ°Ê≥ïÁ¢∫‰øùÊâÄÊúâÂ≠ê‰ªªÂãôÈÉΩËÉΩÊéíÂÖ•Ôºö\n\n";

  // ÊèèËø∞ÂïèÈ°å
  if (criticalIssues.length > 0) {
    userMessage += "üö® ÈóúÈçµÂïèÈ°åÔºö\n";
    criticalIssues.forEach(issue => {
      userMessage += `‚Ä¢ ${issue.description}\n`;
    });
    userMessage += "\n";
  }

  if (highIssues.length > 0) {
    userMessage += "‚ö†Ô∏è ÈáçË¶ÅÂïèÈ°åÔºö\n";
    highIssues.forEach(issue => {
      userMessage += `‚Ä¢ ${issue.description}\n`;
    });
    userMessage += "\n";
  }

  // Êèê‰æõËß£Ê±∫ÊñπÊ°à
  const actionableSteps: string[] = [];
  const highPrioritySuggestions = suggestions.filter(s => s.priority === 'high');

  if (highPrioritySuggestions.length > 0) {
    userMessage += "üí° Âª∫Ë≠∞Ëß£Ê±∫ÊñπÊ°àÔºàÈÅ∏ÊìáÂÖ∂‰∏≠‰∏ÄÁ®ÆÔºâÔºö\n\n";
    
    highPrioritySuggestions.forEach((suggestion, index) => {
      userMessage += `${index + 1}. **${suggestion.description}**\n`;
      userMessage += `   Êìç‰ΩúÔºö${suggestion.actionRequired}\n`;
      userMessage += `   ÊïàÊûúÔºö${suggestion.estimatedImpact}\n\n`;
      
      actionableSteps.push(suggestion.actionRequired);
    });
  }

  // Ê∑ªÂä†ÊôÇÈñìÁµ±Ë®à‰ø°ÊÅØ
  if (timeDeficit > 0) {
    const hoursDeficit = Math.round(timeDeficit / 60 * 10) / 10;
    userMessage += `üìä ÊôÇÈñìÂàÜÊûêÔºöÈÇÑÈúÄË¶Å ${hoursDeficit} Â∞èÊôÇÁöÑÈ°çÂ§ñÂ≠∏ÁøíÊôÇÈñìÊâçËÉΩÂÆåÊàêÊâÄÊúâÂ≠ê‰ªªÂãô„ÄÇ\n\n`;
  }

  userMessage += "Ë´ãÂÆåÊàê‰∏äËø∞Âª∫Ë≠∞ÂæåÂÜç‰ΩøÁî®Ëá™ÂãïÊéíÁ®ãÂäüËÉΩÔºå‰ª•Á¢∫‰øùÊâÄÊúâÂ≠ê‰ªªÂãôÈÉΩËÉΩÊàêÂäüÊéíÂÖ•„ÄÇ";

  return {
    shouldProceed: false,
    userMessage,
    actionableSteps
  };
}

export interface RescheduleResult {
  success: boolean;
  originalSlot?: {
    date: string;
    timeSlot: TimeSlot;
    duration: number;
  };
  newSlot?: {
    date: string;
    timeSlot: TimeSlot;
    duration: number;
  };
  reason: string;
  explanation: string;
  suggestions: string[];
  daysShifted?: number;
  impactedTasks?: Array<{
    id: string;
    title: string;
    originalTime: string;
    newTime: string;
    action: 'moved' | 'delayed' | 'compressed';
  }>;
}

export interface RescheduleOptions {
  prioritizeUrgency?: boolean; // ÂÑ™ÂÖàËÄÉÊÖÆÁ∑äÊÄ•ÊÄß
  allowLateDays?: boolean; // ÂÖÅË®±ÊéíÁ®ãÂà∞ËºÉÊôöÁöÑÊó•Êúü
  maxDaysToSearch?: number; // ÊúÄÂ§öÊêúÂ∞ãÂ§©Êï∏
  preferredTimeOfDay?: 'morning' | 'afternoon' | 'evening' | 'any';
  considerTaskDifficulty?: boolean; // ËÄÉÊÖÆ‰ªªÂãôÈõ£Â∫¶ÂåπÈÖçÊôÇÈñìÊÆµ
  allowTimeCompression?: boolean; // ÂÖÅË®±Â£ìÁ∏ÆÂÖ∂‰ªñ‰ªªÂãôÊôÇÈñì
}

/**
 * Êô∫ËÉΩÈáçÊñ∞ÊéíÁ®ãÂäüËÉΩ
 * ÁÇ∫ÈÄæÊúüÁöÑÂ≠ê‰ªªÂãôÂ∞ãÊâæÊúÄ‰Ω≥ÁöÑÊñ∞ÊôÇÊÆµ
 */
export function intelligentReschedule(
  overdueTask: {
    id: string;
    title: string;
    duration: number;
    priority?: 'low' | 'medium' | 'high';
    difficulty?: 'easy' | 'medium' | 'hard';
    dueDate?: string;
    isSubtask?: boolean;
    mainTaskId?: string;
    phase?: string;
  },
  currentSchedule: ScheduledTask[],
  availableTimeSlots: DayTimeSlots,
  calendarEvents: CalendarEvent[] = [],
  options: RescheduleOptions = {}
): RescheduleResult {
  try {
    const {
      prioritizeUrgency = true,
      allowLateDays = true,
      maxDaysToSearch = 14,
      preferredTimeOfDay = 'any',
      considerTaskDifficulty = true,
      allowTimeCompression = false
    } = options;

    // Â∞ãÊâæÂéüÂßãÊéíÁ®ãÊôÇÊÆµÔºàÁî®ÊñºÊØîËºÉÔºâ
    const originalScheduledTask = currentSchedule.find(st => st.taskId === overdueTask.id);
    
    // Ë®àÁÆó‰ªªÂãôÂÑ™ÂÖàÁ¥öÂàÜÊï∏
    const priorityScore = calculateAdvancedTaskPriority(overdueTask);
    
    // Ë®àÁÆóÁ∑äÊÄ•Á®ãÂ∫¶
    const urgencyLevel = calculateUrgencyLevel(overdueTask.dueDate);
    
    // Â∞ãÊâæÂèØÁî®ÁöÑÊôÇÊÆµÈÅ∏È†Ö
    const candidateSlots = findCandidateTimeSlots(
      overdueTask,
      currentSchedule,
      availableTimeSlots,
      calendarEvents,
      maxDaysToSearch,
      preferredTimeOfDay,
      considerTaskDifficulty
    );

    if (candidateSlots.length === 0) {
      return {
        success: false,
        reason: 'no_available_slots',
        explanation: generateNoSlotsExplanation(overdueTask, urgencyLevel),
        suggestions: generateRescheduleSuggestions(overdueTask, availableTimeSlots, urgencyLevel)
      };
    }

    // ÈÅ∏ÊìáÊúÄ‰Ω≥ÊôÇÊÆµ
    const bestSlot = selectBestTimeSlot(candidateSlots, overdueTask, priorityScore, urgencyLevel);
    
    // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÁßªÂãïÂÖ∂‰ªñ‰ªªÂãô
    const impactAnalysis = analyzeSchedulingImpact(bestSlot, currentSchedule, overdueTask);
    
    // Ë®àÁÆóÊôÇÈñìÂÅèÁßª
    const daysShifted = calculateDaysShifted(
      originalScheduledTask?.date || new Date().toISOString().split('T')[0],
      bestSlot.date
    );

    return {
      success: true,
      originalSlot: originalScheduledTask ? {
        date: originalScheduledTask.date,
        timeSlot: originalScheduledTask.timeSlot,
        duration: originalScheduledTask.duration
      } : undefined,
      newSlot: {
        date: bestSlot.date,
        timeSlot: bestSlot.timeSlot,
        duration: overdueTask.duration
      },
      reason: determineRescheduleReason(bestSlot, urgencyLevel, daysShifted),
      explanation: generateRescheduleExplanation(overdueTask, bestSlot, urgencyLevel, daysShifted),
      suggestions: generateOptimizationSuggestions(overdueTask, bestSlot, impactAnalysis),
      daysShifted,
      impactedTasks: impactAnalysis.impactedTasks
    };

  } catch (error) {
    console.error("Intelligent reschedule error:", error);
    return {
      success: false,
      reason: 'system_error',
      explanation: 'ÈáçÊñ∞ÊéíÁ®ãÊôÇÁôºÁîüÁ≥ªÁµ±ÈåØË™§ÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ',
      suggestions: ['Ê™¢Êü•Á∂≤Ë∑ØÈÄ£Êé•', 'ÈáçÊñ∞ÂïüÂãïÊáâÁî®Á®ãÂºè', 'ËÅØÁπ´ÊäÄË°ìÊîØÊè¥']
    };
  }
}

/**
 * Ë®àÁÆóÈÄ≤Èöé‰ªªÂãôÂÑ™ÂÖàÁ¥öÔºàËÄÉÊÖÆÊõ¥Â§öÂõ†Á¥†Ôºâ
 */
function calculateAdvancedTaskPriority(task: {
  duration: number;
  priority?: 'low' | 'medium' | 'high';
  difficulty?: 'easy' | 'medium' | 'hard';
  dueDate?: string;
  phase?: string;
}): number {
  let score = 0;

  // Âü∫Á§éÂÑ™ÂÖàÁ¥ö
  switch (task.priority) {
    case 'high': score += 50; break;
    case 'medium': score += 30; break;
    case 'low': score += 10; break;
    default: score += 20;
  }

  // Êà™Ê≠¢Êó•ÊúüÁ∑äÊÄ•ÊÄß
  if (task.dueDate) {
    const daysUntilDue = calculateDaysUntil(task.dueDate);
    if (daysUntilDue <= 1) score += 100;
    else if (daysUntilDue <= 3) score += 60;
    else if (daysUntilDue <= 7) score += 30;
    else if (daysUntilDue <= 14) score += 15;
  }

  // ‰ªªÂãôÈõ£Â∫¶ÔºàÂõ∞Èõ£‰ªªÂãôÈúÄË¶ÅÊõ¥Â•ΩÁöÑÊôÇÊÆµÔºâ
  switch (task.difficulty) {
    case 'hard': score += 25; break;
    case 'medium': score += 15; break;
    case 'easy': score += 5; break;
  }

  // Â≠∏ÁøíÈöéÊÆµÊ¨äÈáç
  switch (task.phase) {
    case 'knowledge': score += 20; break;
    case 'practice': score += 15; break;
    case 'application': score += 25; break;
    case 'reflection': score += 10; break;
    case 'output': score += 30; break;
    case 'review': score += 5; break;
  }

  // ‰ªªÂãôÊôÇÈï∑ÔºàÈï∑‰ªªÂãôÊõ¥Èõ£ÂÆâÊéíÔºâ
  if (task.duration >= 120) score += 20;
  else if (task.duration >= 90) score += 15;
  else if (task.duration >= 60) score += 10;

  return score;
}

/**
 * Ë®àÁÆóÁ∑äÊÄ•Á®ãÂ∫¶
 */
function calculateUrgencyLevel(dueDate?: string): 'critical' | 'high' | 'medium' | 'low' {
  if (!dueDate) return 'low';
  
  const days = calculateDaysUntil(dueDate);
  if (days <= 1) return 'critical';
  if (days <= 3) return 'high';
  if (days <= 7) return 'medium';
  return 'low';
}

/**
 * Â∞ãÊâæÂÄôÈÅ∏ÊôÇÊÆµ
 */
function findCandidateTimeSlots(
  task: { duration: number; difficulty?: string; phase?: string },
  currentSchedule: ScheduledTask[],
  availableTimeSlots: DayTimeSlots,
  calendarEvents: CalendarEvent[],
  maxDaysToSearch: number,
  preferredTimeOfDay: string,
  considerTaskDifficulty: boolean
): Array<{
  date: string;
  timeSlot: TimeSlot;
  score: number;
  dayOfWeek: string;
  timeOfDay: 'morning' | 'afternoon' | 'evening';
}> {
  const candidates: Array<{
    date: string;
    timeSlot: TimeSlot;
    score: number;
    dayOfWeek: string;
    timeOfDay: 'morning' | 'afternoon' | 'evening';
  }> = [];

  const startDate = new Date();
  startDate.setDate(startDate.getDate() + 1); // ÂæûÊòéÂ§©ÈñãÂßãÊêúÂ∞ã

  for (let dayOffset = 0; dayOffset < maxDaysToSearch; dayOffset++) {
    const currentDate = addDays(startDate, dayOffset);
    const dayOfWeek = getDayOfWeek(currentDate);
    const dateString = getDateString(currentDate);
    
    const daySlots = availableTimeSlots[dayOfWeek];
    if (!daySlots || daySlots.length === 0) continue;

    for (const slot of daySlots) {
      const availableWindows = findAvailableWindows(
        slot,
        currentSchedule.filter(st => st.date === dateString),
        calendarEvents,
        dateString
      );

      for (const window of availableWindows) {
        const windowDuration = timeToMinutes(window.end) - timeToMinutes(window.start);
        
        if (windowDuration >= task.duration) {
          const timeOfDay = getTimeOfDayCategory(window.start);
          const score = calculateSlotScore(
            window,
            timeOfDay,
            dayOffset,
            task,
            preferredTimeOfDay,
            considerTaskDifficulty
          );

          // üîß Create properly sized time slot for task duration
          const startMinutes = timeToMinutes(window.start);
          const endMinutes = startMinutes + task.duration;
          const calculatedEndTime = minutesToTime(endMinutes);
          
          // üö® Validate that the calculated end time doesn't exceed the available window
          const windowEndMinutes = timeToMinutes(window.end);
          if (endMinutes > windowEndMinutes) {
            console.warn(`‚ö†Ô∏è Task duration ${task.duration}min exceeds available window ${windowDuration}min at ${window.start}-${window.end}`);
            continue; // Skip this candidate
          }

          // üîß Log successful time slot creation for debugging
          console.log(`‚úÖ Created time slot: ${window.start}-${calculatedEndTime} (${task.duration}min) from window ${window.start}-${window.end} (${windowDuration}min)`);

          candidates.push({
            date: dateString,
            timeSlot: {
              start: window.start,
              end: calculatedEndTime
            },
            score,
            dayOfWeek,
            timeOfDay
          });
        }
      }
    }
  }

  // ÊåâÂàÜÊï∏ÊéíÂ∫èÔºàÈ´òÂàÜÂÑ™ÂÖàÔºâ
  return candidates.sort((a, b) => b.score - a.score);
}

/**
 * Áç≤ÂèñÊôÇÊÆµÂàÜÈ°û
 */
function getTimeOfDayCategory(time: string): 'morning' | 'afternoon' | 'evening' {
  const hour = parseInt(time.split(':')[0]);
  if (hour < 12) return 'morning';
  if (hour < 18) return 'afternoon';
  return 'evening';
}

/**
 * Ë®àÁÆóÊôÇÊÆµÂàÜÊï∏
 */
function calculateSlotScore(
  slot: TimeSlot,
  timeOfDay: 'morning' | 'afternoon' | 'evening',
  dayOffset: number,
  task: { difficulty?: string; phase?: string },
  preferredTimeOfDay: string,
  considerTaskDifficulty: boolean
): number {
  let score = 100; // Âü∫Á§éÂàÜÊï∏

  // ÊôÇÈñìÂÅèÂ•ΩÂä†ÂàÜ
  if (preferredTimeOfDay === 'any' || preferredTimeOfDay === timeOfDay) {
    score += 20;
  }

  // Ë∂äÊó©ÁöÑÊó•ÊúüÂàÜÊï∏Ë∂äÈ´ò
  score -= dayOffset * 5;

  // ‰ªªÂãôÈõ£Â∫¶ËàáÊôÇÊÆµÂåπÈÖç
  if (considerTaskDifficulty && task.difficulty) {
    if (task.difficulty === 'hard' && timeOfDay === 'morning') score += 15;
    if (task.difficulty === 'medium' && timeOfDay !== 'evening') score += 10;
    if (task.difficulty === 'easy') score += 5;
  }

  // Â≠∏ÁøíÈöéÊÆµËàáÊôÇÊÆµÂåπÈÖç
  if (task.phase) {
    switch (task.phase) {
      case 'knowledge':
        if (timeOfDay === 'morning') score += 10;
        break;
      case 'practice':
        if (timeOfDay === 'morning' || timeOfDay === 'afternoon') score += 8;
        break;
      case 'application':
        if (timeOfDay === 'afternoon') score += 10;
        break;
      case 'reflection':
        if (timeOfDay === 'evening') score += 12;
        break;
      case 'output':
        if (timeOfDay === 'morning' || timeOfDay === 'afternoon') score += 10;
        break;
    }
  }

  // ÊôÇÊÆµÂ§ßÂ∞èÂä†ÂàÜÔºàÈÅøÂÖçÈÅéÂ∞èÁöÑÊôÇÊÆµÔºâ
  const slotDuration = timeToMinutes(slot.end) - timeToMinutes(slot.start);
  if (slotDuration >= 120) score += 10;
  else if (slotDuration >= 90) score += 5;

  return score;
}

/**
 * ÈÅ∏ÊìáÊúÄ‰Ω≥ÊôÇÊÆµ
 */
function selectBestTimeSlot(
  candidates: Array<{
    date: string;
    timeSlot: TimeSlot;
    score: number;
    dayOfWeek: string;
    timeOfDay: 'morning' | 'afternoon' | 'evening';
  }>,
  task: { id: string; title: string },
  priorityScore: number,
  urgencyLevel: 'critical' | 'high' | 'medium' | 'low'
): {
  date: string;
  timeSlot: TimeSlot;
  score: number;
  dayOfWeek: string;
  timeOfDay: 'morning' | 'afternoon' | 'evening';
} {
  // Â∞çÊñºÁ∑äÊÄ•‰ªªÂãôÔºåÈÅ∏ÊìáÊúÄÊó©ÁöÑÂèØÁî®ÊôÇÊÆµ
  if (urgencyLevel === 'critical' || urgencyLevel === 'high') {
    return candidates[0]; // Â∑≤ÊåâÂàÜÊï∏ÊéíÂ∫èÔºåÁ¨¨‰∏ÄÂÄãÊòØÊúÄ‰Ω≥ÁöÑ
  }

  // Â∞çÊñºÈùûÁ∑äÊÄ•‰ªªÂãôÔºåÂèØ‰ª•ËÄÉÊÖÆÊõ¥Â§öÂõ†Á¥†
  return candidates[0];
}

/**
 * ÂàÜÊûêÊéíÁ®ãÂΩ±Èüø
 */
function analyzeSchedulingImpact(
  newSlot: { date: string; timeSlot: TimeSlot },
  currentSchedule: ScheduledTask[],
  task: { id: string; title: string; duration: number }
): {
  hasConflicts: boolean;
  impactedTasks: Array<{
    id: string;
    title: string;
    originalTime: string;
    newTime: string;
    action: 'moved' | 'delayed' | 'compressed';
  }>;
} {
  // ÁõÆÂâçÂØ¶ÁèæÁ∞°ÂñÆÁâàÊú¨ÔºåÊú™‰æÜÂèØ‰ª•Êì¥Â±ïÂà∞ËôïÁêÜË°ùÁ™Å
  return {
    hasConflicts: false,
    impactedTasks: []
  };
}

/**
 * Ë®àÁÆóÊó•ÊúüÂÅèÁßª
 */
function calculateDaysShifted(originalDate: string, newDate: string): number {
  const original = new Date(originalDate);
  const newDateObj = new Date(newDate);
  const diffTime = newDateObj.getTime() - original.getTime();
  return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
}

/**
 * Á¢∫ÂÆöÈáçÊñ∞ÊéíÁ®ãÂéüÂõ†
 */
function determineRescheduleReason(
  slot: { timeOfDay: string; dayOfWeek: string },
  urgencyLevel: string,
  daysShifted: number
): string {
  if (urgencyLevel === 'critical') {
    return 'urgent_deadline';
  } else if (daysShifted <= 1) {
    return 'next_available';
  } else if (slot.timeOfDay === 'morning') {
    return 'optimal_time';
  } else {
    return 'best_fit';
  }
}

/**
 * ÁîüÊàêÈáçÊñ∞ÊéíÁ®ãË™™Êòé
 */
function generateRescheduleExplanation(
  task: { title: string; duration: number; difficulty?: string },
  slot: { date: string; timeSlot: TimeSlot; timeOfDay: string; dayOfWeek: string },
  urgencyLevel: string,
  daysShifted: number
): string {
  const dateObj = new Date(slot.date);
  const formattedDate = dateObj.toLocaleDateString('zh-TW', { 
    month: 'short', 
    day: 'numeric',
    weekday: 'short'
  });
  
  const timeRange = `${slot.timeSlot.start}-${slot.timeSlot.end}`;
  
  let explanation = `Â∑≤ÊàêÂäüÂ∞á‰ªªÂãôÈáçÊñ∞ÊéíÁ®ãËá≥ ${formattedDate} ${timeRange}`;
  
  if (urgencyLevel === 'critical') {
    explanation += `ÔºàÁ∑äÊÄ•ÔºöË∑ùÈõ¢Êà™Ê≠¢Êó•Êúü‰∏çË∂≥2Â§©Ôºâ`;
  } else if (daysShifted <= 1) {
    explanation += `ÔºàÊòéÂ§©ÁöÑÊúÄ‰Ω≥ÂèØÁî®ÊôÇÊÆµÔºâ`;
  } else if (slot.timeOfDay === 'morning') {
    explanation += `ÔºàÊúÄ‰Ω≥Â≠∏ÁøíÊôÇÊÆµÔºö‰∏äÂçàÊôÇÈñìÊúâÂä©ÊñºÊèêÈ´òÂ∞àÊ≥®ÂäõÔºâ`;
  }
  
  if (task.difficulty === 'hard' && slot.timeOfDay === 'morning') {
    explanation += `„ÄÇÁî±ÊñºÈÄôÊòØÈ´òÈõ£Â∫¶‰ªªÂãôÔºåÂÆâÊéíÂú®Á≤æÂäõÊúÄ‰Ω≥ÁöÑ‰∏äÂçàÊôÇÊÆµ„ÄÇ`;
  } else if (task.duration >= 90) {
    explanation += `„ÄÇËÄÉÊÖÆÂà∞‰ªªÂãôÊôÇÈï∑ËºÉÈï∑Ôºà${task.duration}ÂàÜÈêòÔºâÔºåÈÅ∏Êìá‰∫ÜÂÖÖË∂≥ÁöÑÊôÇÈñìÊÆµ„ÄÇ`;
  }
  
  return explanation;
}

/**
 * ÁîüÊàêÁÑ°ÂèØÁî®ÊôÇÊÆµÁöÑË™™Êòé
 */
function generateNoSlotsExplanation(
  task: { title: string; duration: number; dueDate?: string },
  urgencyLevel: string
): string {
  let explanation = `ÁÑ°Ê≥ïÁÇ∫„Äå${task.title}„ÄçÊâæÂà∞ÂêàÈÅ©ÁöÑÊôÇÈñìÊÆµ`;
  
  if (urgencyLevel === 'critical') {
    explanation += `Ôºå‰∏î‰ªªÂãôÂç≥Â∞áÂà∞Êúü„ÄÇ`;
  } else {
    explanation += `„ÄÇÈúÄË¶Å ${task.duration} ÂàÜÈêòÁöÑÈÄ£Á∫åÊôÇÈñìÔºå‰ΩÜÁèæÊúâÂÆâÊéíÈÅéÊñºÁ∑äÂØÜ„ÄÇ`;
  }
  
  return explanation;
}

/**
 * ÁîüÊàêÈáçÊñ∞ÊéíÁ®ãÂª∫Ë≠∞
 */
function generateRescheduleSuggestions(
  task: { duration: number; dueDate?: string },
  availableTimeSlots: DayTimeSlots,
  urgencyLevel: string
): string[] {
  const suggestions: string[] = [];
  
  if (urgencyLevel === 'critical') {
    suggestions.push('ËÄÉÊÖÆÂª∂Èï∑‰ªªÂãôÊà™Ê≠¢Êó•Êúü');
    suggestions.push('Â∞á‰ªªÂãôÂàÜËß£ÁÇ∫Êõ¥Â∞èÁöÑÂ≠ê‰ªªÂãô');
    suggestions.push('ÂèñÊ∂àÂÖ∂‰ªñÈùûÁ∑äÊÄ•Ê¥ªÂãï‰ª•È®∞Âá∫ÊôÇÈñì');
  } else {
    suggestions.push('Â¢ûÂä†ÊØèÊó•ÂèØÁî®Â≠∏ÁøíÊôÇÊÆµ');
    suggestions.push('ËÄÉÊÖÆÂ∞áÈï∑ÊôÇÈñì‰ªªÂãôÊãÜÂàÜÁÇ∫Â§öÂÄãËºÉÁü≠ÁöÑÊôÇÊÆµ');
    suggestions.push('Ë™øÊï¥ÂÖ∂‰ªñ‰ªªÂãôÁöÑÂÑ™ÂÖàÁ¥ö');
  }
  
  // ÂàÜÊûêÂèØÁî®ÊôÇÊÆµ‰∏¶Êèê‰æõÂÖ∑È´îÂª∫Ë≠∞
  const totalAvailableTime = calculateTotalAvailableTime(availableTimeSlots);
  if (totalAvailableTime < task.duration * 2) {
    suggestions.push('ÊÇ®ÁöÑÊØèÊó•ÂèØÁî®ÊôÇÈñìÂèØËÉΩ‰∏çË∂≥ÔºåÂª∫Ë≠∞Â¢ûÂä†Â≠∏ÁøíÊôÇÈñìÈÖçÁΩÆ');
  }
  
  return suggestions;
}

/**
 * ÁîüÊàêÂÑ™ÂåñÂª∫Ë≠∞
 */
function generateOptimizationSuggestions(
  task: { title: string; duration: number },
  slot: { date: string; timeOfDay: string },
  impactAnalysis: { hasConflicts: boolean; impactedTasks: any[] }
): string[] {
  const suggestions: string[] = [];
  
  if (slot.timeOfDay === 'evening') {
    suggestions.push('ËÄÉÊÖÆË™øÊï¥‰ΩúÊÅØÔºåÂ∞áÈáçË¶Å‰ªªÂãôÂÆâÊéíÂú®‰∏äÂçà‰ª•ÊèêÈ´òÊïàÁéá');
  }
  
  if (task.duration >= 120) {
    suggestions.push('ËÄÉÊÖÆ‰ΩøÁî®Áï™ËåÑÈêòÊäÄÂ∑ßÔºåÂ∞áÈï∑ÊôÇÈñì‰ªªÂãôÂàÜÊàêÂ§öÂÄãÂ∞àÊ≥®ÊôÇÊÆµ');
  }
  
  suggestions.push('Ë®≠ÂÆöÊèêÈÜíÈÅøÂÖçÂÜçÊ¨°ÈåØÈÅéÊéíÁ®ãÊôÇÈñì');
  
  return suggestions;
}

/**
 * Ë®àÁÆóÁ∏ΩÂèØÁî®ÊôÇÈñì
 */
function calculateTotalAvailableTime(availableTimeSlots: DayTimeSlots): number {
  let totalMinutes = 0;
  
  Object.values(availableTimeSlots).forEach(daySlots => {
    daySlots.forEach((slot: TimeSlot) => {
      totalMinutes += timeToMinutes(slot.end) - timeToMinutes(slot.start);
    });
  });
  
  return totalMinutes / 7; // ÊØèÊó•Âπ≥ÂùáÂèØÁî®ÊôÇÈñì
}

/**
 * üîß Validate duration integrity and suggest solutions for compression issues
 */
export function validateTaskDuration(
  task: {
    id: string;
    title: string;
    duration: number;
    originalDuration?: number;
    difficulty?: string;
  },
  availableTimeSlots: DayTimeSlots
): {
  isValid: boolean;
  issues: string[];
  suggestions: string[];
  recommendSplit: boolean;
  maxAvailableSlot: number;
} {
  const issues: string[] = [];
  const suggestions: string[] = [];
  let recommendSplit = false;
  
  // Find maximum available time slot
  let maxAvailableSlot = 0;
  Object.values(availableTimeSlots).forEach(daySlots => {
    daySlots.forEach((slot: TimeSlot) => {
      const slotDuration = timeToMinutes(slot.end) - timeToMinutes(slot.start);
      maxAvailableSlot = Math.max(maxAvailableSlot, slotDuration);
    });
  });

  // Check for duration compression
  if (task.originalDuration && task.duration < task.originalDuration * 0.8) {
    const compressionPercent = Math.round((1 - task.duration / task.originalDuration) * 100);
    issues.push(`Duration compressed by ${compressionPercent}% (${task.originalDuration}min ‚Üí ${task.duration}min)`);
    suggestions.push('Use original estimated duration for rescheduling');
  }

  // Check if task duration exceeds available slots
  if (task.duration > maxAvailableSlot) {
    issues.push(`Task duration (${task.duration}min) exceeds largest available slot (${maxAvailableSlot}min)`);
    recommendSplit = true;
    suggestions.push(`Split task into ${Math.ceil(task.duration / maxAvailableSlot)} sessions`);
    suggestions.push('Extend available time slots');
    suggestions.push('Consider reducing task scope');
  }

  // Check for unrealistically short durations
  if (task.duration < 15) {
    issues.push(`Duration too short (${task.duration}min) for meaningful work`);
    suggestions.push('Combine with related tasks');
    suggestions.push('Review task breakdown accuracy');
  }

  // Check difficulty vs duration mismatch
  if (task.difficulty === 'hard' && task.duration < 30) {
    issues.push('Hard task with very short duration may indicate compression');
    suggestions.push('Review task complexity and time estimates');
  }

  return {
    isValid: issues.length === 0,
    issues,
    suggestions,
    recommendSplit,
    maxAvailableSlot
  };
}

/**
 * üîß Enhanced reschedule with duration validation
 */
export function intelligentRescheduleWithValidation(
  overdueTask: {
    id: string;
    title: string;
    duration: number;
    originalDuration?: number;
    priority?: 'low' | 'medium' | 'high';
    difficulty?: 'easy' | 'medium' | 'hard';
    dueDate?: string;
    isSubtask?: boolean;
    mainTaskId?: string;
    phase?: string;
  },
  currentSchedule: ScheduledTask[],
  availableTimeSlots: DayTimeSlots,
  calendarEvents: CalendarEvent[] = [],
  options: RescheduleOptions = {}
): RescheduleResult {
  // üîß Validate task duration first
  const validation = validateTaskDuration(overdueTask, availableTimeSlots);
  
  if (!validation.isValid) {
    console.warn(`‚ö†Ô∏è Duration validation failed for task ${overdueTask.id}:`, validation.issues);
    
    // If task should be split, provide splitting suggestion
    if (validation.recommendSplit) {
      return {
        success: false,
        reason: 'task_too_long',
        explanation: `Task duration (${overdueTask.duration}min) exceeds available time slots (max: ${validation.maxAvailableSlot}min). Consider splitting this task into smaller segments.`,
        suggestions: [
          ...validation.suggestions,
          'Split task into multiple shorter sessions',
          'Schedule across multiple days',
          'Increase available time slots'
        ]
      };
    }
  }

  // Use original duration if compression detected
  const adjustedTask = {
    ...overdueTask,
    duration: overdueTask.originalDuration && overdueTask.duration < overdueTask.originalDuration * 0.8 
      ? overdueTask.originalDuration 
      : overdueTask.duration
  };

  console.log(`üîß Using adjusted duration: ${adjustedTask.duration}min (original: ${overdueTask.duration}min)`);

  // Proceed with standard rescheduling
  return intelligentReschedule(adjustedTask, currentSchedule, availableTimeSlots, calendarEvents, options);
}

/**
 * üÜï Ê†πÊìö scheduledTasks ÂãïÊÖãË®àÁÆóÊâÄÊúâË¢´‰ΩîÁî®ÁöÑÊôÇÊÆµ
 * @param scheduledTasks - Áï∂ÂâçÊâÄÊúâÂ∑≤ÊéíÁ®ã‰ªªÂãô
 * @returns { [date: string]: Array<{ start: string; end: string }> }
 */
export function getTrueOccupiedTimeSlots(scheduledTasks: ScheduledTask[]): Record<string, Array<{ start: string; end: string }>> {
  const occupied: Record<string, Array<{ start: string; end: string }>> = {};
  scheduledTasks.forEach(task => {
    if (!occupied[task.date]) occupied[task.date] = [];
    occupied[task.date].push({ start: task.timeSlot.start, end: task.timeSlot.end });
  });
  return occupied;
}